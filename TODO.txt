May 2020
---------

Domains
--------

- Domain create traits should be unified --- we don't need 20 identical traits, 
  we only need one for each type -- the create has to take a blob as an argument

- Domain destroy logic -- when? Explicit call? Reference count drops to 0 (most 
  likely)?  -- that's a big one. 

- Call domain init function through the proxy/continuation -- domain might
  panic on entry.  

     > Can we wrap the domain init with unwind? From within the generated domain
       init 
     > yeah, that's a good strategy too, we can rely on normal Rust panic
       mechanism... but it doesn't work because we really might want to terminate an
       undresponsive init function inside the domain with a timeout

RRefs

- We shall carefully reason about the race condition when the accessor moves
  the reference outside of the domain. What happens when the domain crashes
right there in the middle of the operation? Imagine the thread gets slow and it
took the RRef out the Option is empty, but not yet assigned domain id to the
RRef. If we unwind the thread to the proxy, the id will never get assigned.  I
think we need to introduce some notion of the _do_not_unwind_ flag that can be
set from a trusted place, like from the accessor to make sure that the thread
continues to run until it leaves the _do_not_unwind_ block. 

Recovery/shadows

- Protect the RpcErr type with an unsafe constructor so the domain cannot itself 
  return a failure Err(Unwind) and fake unwind

- How do we shut down the DMA engine when device driver domain crashes? We need some 
  notion of destructors, but for what? Who owns the BAR and runst the device? The owner of 
  the BAR capability. So the BAR has to be on the shared heap and we should call its
  destructor.  

-------------------------------------------------------------------------------
--
-- OLD (possibly irrelevant)
--
-------------------------------------------------------------------------------

Domains
-------
 -- Support for memory allocator to run Box [Vikram, done]

 -- We need "domain_create()" system call and how we pass system calls
    
     - Here it's a bit tricky, we need to pass unique system calls into each
       domain type. For example, device drvier domains get ukern syscalls, xv6
domains get both xv6 system calls and ukern syscalls (maybe it's not strictly
needed (we thought we need this for memory allocator to work, but maybe xv6 can
implement it's own allocator, but maybe it's not possible as it has to be
unsafe)

domain_create() 

  - Jump into entry point with a specific set of system calls (i.e., ukern
    syscalls), we don't create a new thread (domains can be passive). If the
domain needs a thread it will create it inside the main() function.  

  - TSS support for per-thread data structures

  - Scheduler support to "create or migrate threads to specific CPUs" 

  - Syscall wrappers  [done]

  - support for println system call [done]

xv6
-----

 -- Move xv6 into ELF files [Tian?]

 -- Interrupt support for xv6, i.e. we need a layer that 
    starts interrupts as threads, the thread is parked waiting on an interrupt 
    and is woken up when the interrupt arrives

 - Scheduling support, i.e., all system calls to allow control over scheduling
   decisions


 -- xv6 user process creation 

    -- Need to figure out a prototype for "safe compilation" 

Device drviers
--------------

-- Move block device driver into loadable domains


Software Fault Isolation
------------------------

 -- Interface wrapping

Secure compilation
--------------------------------------------------------------------

 -- Generation of the  

